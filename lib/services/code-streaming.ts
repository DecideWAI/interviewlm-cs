/**
 * Code Streaming Service
 *
 * Manages real-time code streaming from AI to editor via Server-Sent Events (SSE).
 * Allows candidates to see code being generated by AI in real-time.
 */

import { EventEmitter } from 'events';

export interface CodeStreamEvent {
  sessionId: string;
  fileName: string;
  delta?: string; // Incremental code chunk
  fullContent?: string; // Complete file content
  position?: {
    line: number;
    column: number;
  };
  type: 'delta' | 'complete' | 'start' | 'error';
  error?: string;
}

// Track active streaming operations to prevent overlapping
const activeStreams = new Map<string, boolean>(); // key: `${sessionId}:${fileName}`

/**
 * Code Stream Manager
 * Manages SSE connections and broadcasts code updates
 */
class CodeStreamManager extends EventEmitter {
  private static instance: CodeStreamManager;
  private activeStreams: Map<string, Set<string>> = new Map(); // sessionId -> Set<clientId>

  private constructor() {
    super();
    this.setMaxListeners(100); // Support many concurrent streams
  }

  static getInstance(): CodeStreamManager {
    if (!CodeStreamManager.instance) {
      CodeStreamManager.instance = new CodeStreamManager();
    }
    return CodeStreamManager.instance;
  }

  /**
   * Register a new SSE connection for a session
   */
  registerClient(sessionId: string, clientId: string): void {
    if (!this.activeStreams.has(sessionId)) {
      this.activeStreams.set(sessionId, new Set());
    }
    this.activeStreams.get(sessionId)!.add(clientId);
  }

  /**
   * Unregister an SSE connection
   */
  unregisterClient(sessionId: string, clientId: string): void {
    const clients = this.activeStreams.get(sessionId);
    if (clients) {
      clients.delete(clientId);
      if (clients.size === 0) {
        this.activeStreams.delete(sessionId);
      }
    }
  }

  /**
   * Stream code delta to all connected clients for a session
   */
  streamCodeDelta(event: CodeStreamEvent): void {
    const clients = this.activeStreams.get(event.sessionId);
    if (!clients || clients.size === 0) {
      // No active clients - silently skip (this is normal when SSE not connected)
      return;
    }

    // Emit event to all registered listeners
    this.emit(event.sessionId, event);
  }

  /**
   * Start streaming for a file
   */
  startStreaming(sessionId: string, fileName: string): void {
    this.streamCodeDelta({
      sessionId,
      fileName,
      type: 'start',
    });
  }

  /**
   * Complete streaming for a file
   */
  completeStreaming(sessionId: string, fileName: string, fullContent: string): void {
    this.streamCodeDelta({
      sessionId,
      fileName,
      fullContent,
      type: 'complete',
    });
  }

  /**
   * Stream error
   */
  streamError(sessionId: string, fileName: string, error: string): void {
    this.streamCodeDelta({
      sessionId,
      fileName,
      error,
      type: 'error',
    });
  }

  /**
   * Check if session has active streams
   */
  hasActiveStreams(sessionId: string): boolean {
    const clients = this.activeStreams.get(sessionId);
    return clients !== undefined && clients.size > 0;
  }

  /**
   * Get count of active streams for a session
   */
  getStreamCount(sessionId: string): number {
    return this.activeStreams.get(sessionId)?.size || 0;
  }
}

export const codeStreamManager = CodeStreamManager.getInstance();

/**
 * Create SSE response stream for code updates
 */
export function createCodeStreamResponse(
  sessionId: string,
  controller: ReadableStreamDefaultController<Uint8Array>
): { clientId: string; cleanup: () => void } {
  const encoder = new TextEncoder();
  const clientId = `client_${Date.now()}_${Math.random().toString(36).substring(7)}`;

  // Register client
  codeStreamManager.registerClient(sessionId, clientId);

  // Event listener for code updates
  const eventListener = (event: CodeStreamEvent) => {
    try {
      const data = JSON.stringify(event);
      controller.enqueue(encoder.encode(`event: code\ndata: ${data}\n\n`));
    } catch (error) {
      console.error('[CodeStreaming] Error sending event:', error);
    }
  };

  // Register event listener
  codeStreamManager.on(sessionId, eventListener);

  // Send initial connection event
  controller.enqueue(
    encoder.encode(`event: connected\ndata: ${JSON.stringify({ clientId })}\n\n`)
  );

  // Cleanup function
  const cleanup = () => {
    codeStreamManager.off(sessionId, eventListener);
    codeStreamManager.unregisterClient(sessionId, clientId);
  };

  return { clientId, cleanup };
}

/**
 * Stream code generation in chunks
 * Simulates typing effect by sending small deltas
 */
export async function streamCodeGeneration(
  sessionId: string,
  fileName: string,
  fullCode: string,
  options: {
    chunkSize?: number; // Characters per chunk
    delayMs?: number; // Delay between chunks
  } = {}
): Promise<void> {
  // Guard against undefined/null code
  if (!fullCode) {
    return;
  }

  // Prevent overlapping streams for the same file
  const streamKey = `${sessionId}:${fileName}`;
  if (activeStreams.get(streamKey)) {
    // Previous stream still running - skip this one
    return;
  }

  // Skip streaming if no active clients (avoid unnecessary work)
  if (!codeStreamManager.hasActiveStreams(sessionId)) {
    return;
  }

  activeStreams.set(streamKey, true);

  try {
    const { chunkSize = 5, delayMs = 20 } = options;

    // Start streaming
    codeStreamManager.startStreaming(sessionId, fileName);

    // Track cursor position
    let currentLine = 1; // Lines start at 1
    let currentColumn = 0; // Columns start at 0

    // Stream in chunks
    for (let i = 0; i < fullCode.length; i += chunkSize) {
      const chunk = fullCode.substring(i, Math.min(i + chunkSize, fullCode.length));

      // Calculate position based on content streamed so far
      // Count newlines in the chunk
      for (let j = 0; j < chunk.length; j++) {
        const char = chunk[j];
        if (char === '\n') {
          currentLine++;
          currentColumn = 0;
        } else {
          currentColumn++;
        }
      }

      codeStreamManager.streamCodeDelta({
        sessionId,
        fileName,
        delta: chunk,
        type: 'delta',
        position: {
          line: currentLine,
          column: currentColumn,
        },
      });

      // Small delay to create typing effect
      if (i + chunkSize < fullCode.length) {
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    }

    // Complete streaming
    codeStreamManager.completeStreaming(sessionId, fileName, fullCode);
  } finally {
    activeStreams.delete(streamKey);
  }
}
